---
const { municipio, codigo, provincia } = Astro.props;
const chartId = `grafica-edades-${codigo}`;
---

<div class="grafica-container">
  <div class="municipalities-stack" id={chartId}></div>
</div>

<script define:vars={{ municipio, codigo, provincia, chartId }}>
  import { select } from 'd3-selection';
  import { scaleLinear, scaleTime, scaleOrdinal } from 'd3-scale';
  import { stack, area } from 'd3-shape';
  import { axisBottom, axisLeft } from 'd3-axis';
  import { csv } from 'd3-fetch';
  import { max, extent, group } from 'd3-array';

  document.addEventListener('DOMContentLoaded', () => {
    const margin = { top: 40, right: 8, bottom: 24, left: 32 };
    const width = 800 - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;

    const container = select(`#${chartId}`);

    const svg = container.append("svg")
      .attr("width", "100%")
      .attr("height", height + margin.top + margin.bottom)
      .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const csvPath = `/data/${provincia}/grupos-edad/${codigo}.csv`;

    csv(csvPath).then(data => {
      data.forEach(d => {
        d.year = +d.year;
        d.total = +d.total;
        d.age = d.age; // Categoría de edad
      });

      // Agrupar por año y edad para stackedData
      let groupedMap = group(
        data,
        d => d.year,
        d => d.age
      );

      // Obtener todas las categorías de edad únicas
      let stackKeys = [...new Set(data.map(d => d.age))];

      // Crear los datos apilados
      const dataStacked = Array.from(groupedMap.entries())
        .map(g => {
          const obj = { year: g[0] };
          for (let col of stackKeys) {
            const vals = g[1].get(col);
            obj[col] = !vals ? 0 : vals[0].total;
          }
          return obj;
        })
        .sort((a, b) => a.year - b.year);

      // Configurar escalas
      const x = scaleTime()
        .domain(extent(dataStacked, d => d.year))
        .range([0, width]);

      // Configurar stack
      const stackGenerator = stack().keys(stackKeys);
      const stackedData = stackGenerator(dataStacked);

      // Escala para Y
      const y = scaleLinear()
        .domain([0, max(stackedData, d => max(d, d => d[1]))])
        .range([height, 0]);

      // Colores
      const colors = scaleOrdinal()
        .domain(stackKeys)
        .range(["#9db7c5", "#18857f", "#1f4196"]);

      // Función de área
      const areaGenerator = area()
        .x(d => x(d.data.year))
        .y0(d => y(d[0]))
        .y1(d => y(d[1]));

      // Dibujar áreas apiladas
      svg.selectAll(".area-stack")
        .data(stackedData)
        .enter()
        .append("path")
        .attr("class", "area-stack")
        .attr("fill", d => colors(d.key))
        .attr("d", areaGenerator);

      // Añadir leyenda
      const legend = svg.selectAll('.label')
        .data(colors.domain())
        .enter()
        .append('g')
        .attr('class', 'label')
        .attr('transform', (d, i) => `translate(${i * 100}, -20)`);

      legend.append('rect')
        .attr('width', 15)
        .attr('height', 15)
        .style('fill', d => colors(d));

      legend.append('text')
        .attr('x', 20)
        .attr('y', 9)
        .attr('dy', '.35em')
        .text(d => `${d} años`);

      // Añadir ejes
      svg.append("g")
        .attr("class", "axis axis-x")
        .attr("transform", `translate(0,${height})`)
        .call(axisBottom(x).tickFormat(d => d));

      svg.append("g")
        .attr("class", "axis axis-y")
        .call(axisLeft(y));
    });
  });
</script>
